"""perceptron.py
Implements perceptron learning algorithm from Machine Learning by Stephen Marsland.

Written by Joe Reistetter
"""

import numpy as np

def import_data(path, digits=None):
    """Imports data formatted for the digit writing task.
    
    format: csv, first n-1 cols are features, last col is answer.
    
    params:
    path -- path to datafile
    digits -- list containing digits to distinguish
    
    returns:
    filtered_arr -- numpy array with features and -1 bias col appended
    answers --  vector of digits represented by associated features.
                recodes lower digit to 0, higher digit to 1.
    """
    arr = np.genfromtxt(path, dtype="i8", delimiter = ",")
    
    if digits:
        filtered_arr = []
        for row in arr:
            if row[-1] in digits:
                filtered_arr.append(list(row))
       
        filtered_arr = np.array(filtered_arr)
        n_col = filtered_arr.shape[1]
        answers = filtered_arr[:,n_col-1]
        answers = filter_digit(answers, digits)
        answers = np.array(answers)
        filtered_arr[:,n_col-1] = -1
        return filtered_arr, answers

    return arr

def filter_digit(answers, digits):
    """Goes through input answers and recodes lower digit to 0
    upper digit to 1"""
    smaller = min(digits)
    return [0 if val == smaller else 1 for val in answers]

def set_init_w(n_inputs):
    return np.random.rand(n_inputs) * 0.1 - 0.05

def activation(input_vec, weights):
    """Use features and weights to calculate input to neuron
    and if it will fire"""
    neuron_input = sum(input_vec * weights)
    if neuron_input >= 1:
        return 1
    
    return 0

    return neuron_activation

def update_weights(input_vec, weights, activation, answers, learning_rate):
    """Update the weights based on 2.3 on page 23"""
    errors = answers - activation
    weights += learning_rate*errors*input_vec
    return weights

def train(features, answers, epochs, learning_rate):
    """Train a neural network to discrminate between two digits
    
    params:
    features -- 2-d numpy array processed by import_data
    answers -- 1-d numpy array of correct digit processed by import_data
    epochs -- number of iterations to train network
    learning_rate -- rate to adjust weights
    
    returns:
    weights -- 1-d numpy array of the final weights from trained network
    """
    weights = set_init_w(features.shape[1])
    
    while epochs > 0:
        for i, input_vec in enumerate(features):
            activated = activation(input_vec, weights)
            answer = answers[i]
            weights = update_weights(input_vec, weights, activated, answer, learning_rate)
        
        epochs -= epochs
    
    return weights


def test_network(features, answers, weights):
    """Uses test data to determine accuracy of network generated by train
    
    params:
    features -- 2-d numpy array processed by import_data
    answers -- 1-d numpy array of correct digit processed by import_data
    weights -- 1-d numpy array of weights generated by train
    
    returns:
    n_correct -- number of digits correctly predicted
    accuracy -- percent correctly predicted
    
    """
    predictions = zeros(features.shape[0])
    
    for i, input_vec in enumerate(features):
        predictions[i] = activation(input_vec, weights)
    
    n_correct = sum(predictions == answers)
    accuracy = (n_correct / features.shape[0])
    
    return n_correct, accuracy
    
    
    
    
    
